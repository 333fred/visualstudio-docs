---
title: "MSB4211 diagnostic code"
description: "The property 'value' is being set to a value for the first time, but it was already consumed at 'value'."
ms.date: 1/15/2025
ms.topic: "error-reference"
f1_keywords:
 - MSB4211
 - MSBuild.UsedUninitializedProperty
dev_langs:
  - "VB"
  - "CSharp"
  - "C++"
  - "FSharp"
author: ghogen
ms.author: ghogen
manager: mijacobs
ms.subservice: msbuild
---

# MSB4211 diagnostic code

<!-- :::ErrorDefinitionDescription::: -->
<!-- :::editable-content name="introDescription"::: -->
This article describes the MSB4211 error code.
<!-- :::editable-content-end::: -->

## Message text

```output
MSB4211: The property 'value' is being set to a value for the first time, but it was already consumed at 'value'.
```

<!-- :::editable-content name="postOutputDescription"::: -->
<!--
{StrBegin="MSB4211: "}
-->

## Context and Analysis of `UsedUninitializedProperty`

### Instance 1: Logging Error in Uninitialized Property Usage

#### **Context**
In the MSBuild source code, `UsedUninitializedProperty` is typically logged when an MSBuild project references a property that has not been assigned a value. For example, this error may be triggered during the evaluation phase when a target or task attempts to resolve a property that is either undefined or explicitly uninitialized.

The error is usually generated in the property evaluation logic, located in methods where MSBuild parses and resolves property values from the project file. Specifically, this occurs in the property evaluation logic within the `ProjectPropertyInstance` or `PropertyDictionary` classes, where the project system attempts to dereference a property that is expected to have been initialized earlier.

#### **Possible Cause**
This error arises because:

1. A property is referenced in the project file but was never explicitly defined (e.g., `<PropertyName />` or missing `<PropertyName>` block).
2. The property is conditionally defined, but the conditions to initialize it are not met during the build process.
3. Dependency properties are not propagated correctly between targets or projects.

For example:
```xml
<PropertyGroup>
  <OutputPath Condition="'$(Configuration)' == 'Debug'">bin\Debug\</OutputPath>
</PropertyGroup>

<Message Text="OutputPath: $(OutputPath)" />
```
If the `Configuration` property is not set to `Debug`, the `OutputPath` property will remain uninitialized, leading to the `UsedUninitializedProperty` error.

#### **Resolution or Workaround**
1. **Define Default Values for Properties**:
    Always provide default values for properties to ensure they are initialized, regardless of conditions.
    ```xml
    <PropertyGroup>
      <OutputPath>bin\Default\</OutputPath>
      <OutputPath Condition="'$(Configuration)' == 'Debug'">bin\Debug\</OutputPath>
    </PropertyGroup>
    ```

2. **Use Conditional Logging for Debugging**:
    Log properties only after confirming they are initialized:
    ```xml
    <Message Condition="'$(OutputPath)' != ''" Text="OutputPath: $(OutputPath)" />
    ```

3. **Check Property Initialization in Custom Tasks**:
    When writing custom MSBuild tasks, ensure properties are validated before use:
    ```csharp
    if (string.IsNullOrEmpty(OutputPath))
    {
        Log.LogError("UsedUninitializedProperty: OutputPath is not initialized.");
    }
    ```

### Instance 2: Error in Target Dependency Resolution

#### **Context**
Another occurrence of the `UsedUninitializedProperty` error is during target dependency resolution. MSBuild evaluates project dependencies by resolving properties shared between targets. If a shared property is not initialized before being passed from one target to another, the error is logged.

For example:
```xml
<Target Name="TargetA">
  <PropertyGroup>
    <SharedProperty>ValueA</SharedProperty>
  </PropertyGroup>
</Target>

<Target Name="TargetB" DependsOnTargets="TargetA">
  <Message Text="SharedProperty: $(SharedProperty)" />
</Target>
```
If `TargetA` fails to execute or the property initialization in `TargetA` is conditional, `SharedProperty` may remain uninitialized when `TargetB` tries to use it.

#### **Possible Cause**
1. The property is conditionally initialized in the first target, and the condition is not met.
2. The target that initializes the property is skipped due to incremental build logic or a dependency failure.
3. Circular dependencies between targets prevent proper initialization.

#### **Resolution or Workaround**
1. **Validate Dependency Execution**:
    Ensure that all targets in the dependency chain are executed before the property is used. Use the `DependsOnTargets` attribute effectively.

2. **Initialize Properties with Default Values**:
    Set default values for shared properties in the root-level `<PropertyGroup>`:
    ```xml
    <PropertyGroup>
      <SharedProperty>DefaultValue</SharedProperty>
    </PropertyGroup>
    ```

3. **Use Target Outputs**:
    Pass property values explicitly as target outputs instead of relying on global properties:
    ```xml
    <Target Name="TargetA">
      <PropertyGroup>
        <SharedProperty>ValueA</SharedProperty>
      </PropertyGroup>
      <Output TaskParameter="SharedProperty" PropertyName="SharedProperty" />
    </Target>
    ```

### Instance 3: Issue in Custom Task Implementation

#### **Context**
Custom tasks in MSBuild can also trigger the `UsedUninitializedProperty` error. When a custom task accesses a property that is uninitialized or improperly passed from the project file, the error is logged. This often occurs in the `Execute` method of a custom task class.

For example:
```csharp
public class MyCustomTask : Task
{
    [Required]
    public string RequiredProperty { get; set; }

    public override bool Execute()
    {
        if (string.IsNullOrEmpty(RequiredProperty))
        {
            Log.LogError("UsedUninitializedProperty: RequiredProperty is not initialized.");
            return false;
        }

        // Task logic here
        return true;
    }
}
```

#### **Possible Cause**
1. The property is marked with the `[Required]` attribute but is not passed from the MSBuild script.
2. The MSBuild script conditionally passes the property value, and the condition is not met.
3. The property is computed dynamically, but the computation fails or is skipped.

#### **Resolution or Workaround**
1. **Ensure Required Properties Are Set**:
    Validate that all required properties are passed in the MSBuild script:
    ```xml
    <MyCustomTask RequiredProperty="SomeValue" />
    ```

2. **Provide Default Values in Tasks**:
    Assign default values to optional properties in the task implementation:
    ```csharp
    public string OptionalProperty { get; set; } = "DefaultValue";
    ```

3. **Handle Missing Properties Gracefully**:
    Modify the task to log warnings instead of errors for missing optional properties and provide fallback logic:
    ```csharp
    if (string.IsNullOrEmpty(OptionalProperty))
    {
        Log.LogWarning("OptionalProperty is not set. Using default value.");
        OptionalProperty = "DefaultValue";
    }
    ```

## Summary

The `UsedUninitializedProperty` error in MSBuild occurs primarily due to missing or improperly initialized properties. By analyzing each instance:

1. **Common Causes**:
    - Conditional property initialization.
    - Missing dependencies between targets.
    - Errors in custom task implementations.

2. **Resolutions**:
    - Define default values for all properties.
    - Validate property initialization at runtime.
    - Use conditional logging and error handling to prevent build failures.

Each resolution strategy ensures robust and predictable property management within MSBuild projects.
<!-- :::editable-content-end::: -->
<!-- :::ErrorDefinitionDescription-end::: -->

## Applies to

All versions of MSBuild
